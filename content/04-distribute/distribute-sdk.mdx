---
title: With the SDK
description: Distribute Assets with the Polymesh SDK
slug: /distribute/sdk
---

import {MultiCodeBlock} from 'gatsby-theme-apollo-docs';
import HighlightBox from "../../src/components/HighlightBox"

As always, everything that can be done via the Token Studio dashboard can be integrated with internal systems using the SDK. Use this to automate and scale repetitive processes. Let us see how ACME's share distribution would be performed using methods in the SDK. What we want to achieve is for ACME to issue 20,000 shares of ACME Co to Alice the individual. As CEO, Alice will act for ACME.

## Preconditions

We assume that:

* Alice, ACME Co's CEO and acting agent, already has a Polymesh identity, `ceo`.
* Alice the CEO can [instantiate](https://developers.polymath.network/polymesh-sdk-api-reference/classes/polymesh#static-connect) a Polymesh client whenever she needs to act with:
    <MultiCodeBlock>

    ```typescript
    const apiCeo: Polymesh = await Polymesh.connect({
        "nodeUrl": "wss://alcyone-rpc.polymesh.live", // For instance, or the proper network
        "accountMnemonic": "word1 word2 ..."
    });
    ```

    ```javascript
    const apiCeo = await Polymesh.connect({
        "nodeUrl": "wss://alcyone-rpc.polymesh.live", // For instance, or the proper network
        "accountMnemonic": "word1 word2 ..."
    });
    ```

    </MultiCodeBlock>
* The ACME token has already been created.
    <MultiCodeBlock>

    ```typescript
    const token: SecurityToken = await apiCeo.getSecurityToken({
        "ticker" :"ACME"
    });
    ```

    ```javascript
    const token = await apiCeo.getSecurityToken({
        "ticker" :"ACME"
    });
    ```

    </MultiCodeBlock>
* Alice, acting as the CEO, is the owner of the ACME token and also its primary issuance agent.
* Alice has another identity, `alice`, that represents her as an individual.
* Alice the individual also can [instantiate](https://developers.polymath.network/polymesh-sdk-api-reference/classes/polymesh#static-connect) a Polymesh client whenever she needs to act with:
    <MultiCodeBlock>

    ```typescript
    const apiAlice: Polymesh = await Polymesh.connect({
        "nodeUrl": "wss://alcyone-rpc.polymesh.live",
        "accountMnemonic": "word21 word22 ..."
    });
    ```

    ```javascript
    const apiAlice = await Polymesh.connect({
        "nodeUrl": "wss://alcyone-rpc.polymesh.live",
        "accountMnemonic": "word21 word22 ..."
    });
    ```

    </MultiCodeBlock>

## Prepare the distribution

Time for Alice to get her agreed amount of shares. As we mentioned in the previous chapter, implicit in `const token` is that the `context` is `apiCeo`, because we used `apiCeo` to retrieve its information. In other words, any action performed on a `token` inflated by `apiCeo` will effectively be done by Alice the CEO.

At the time of its creation, the ACME token had a total supply of zero. Alice is personally entitled to 20,000 Of the eventual 100,000 total supply of shares that the founders intend to issue. The primary issuance agent (Alice as CEO) first issues, in effect mints, the shares to themselves, then sends them to their ultimate beneficiary(ies), like Alice. Sending securities to someone needs the consent of the recipient. The correct Polymesh structure to achieve that is to create a settlement instruction. And all settlement instructions are created in a venue. Therefore, we will create venue. 

Let's get started:

<MultiCodeBlock>

```typescript
const ceo: CurrentIdentity = await apiCeo.getCurrentIdentity();
const distributionVenueQueue: TransactionQueue<Venue> = await ceo.createVenue({
    "type": VenueType.Distribution,
    "details": "For ACME Co"
});
const distributionVenue: Venue = await distributionVenueQueue.run();
const distributionVenueId: string = distributionVenue.id.toString();
```

```javascript
const ceo = await apiCeo.getCurrentIdentity();
const distributionVenueQueue = await ceo.createVenue({
    "type": "Distribution",
    "details": "For ACME Co"
});
const distributionVenue = await distributionVenueQueue.run();
const distributionVenueId = distributionVenue.id.toString();
```

</MultiCodeBlock>

We keep `distributionVenueId`, the string id of the venue, for later as this is information that will need to be shared with the ultimate recipient. Now that we have the venue, let's have the CEO [issue](https://developers.polymath.network/polymesh-sdk-api-reference/v/docs%2Falpha/classes/issuance#issue) enough shares to later transfer to Alice. Of course, if the CEO planned on issuing shares for all founders of ACME Co, she would issue more.

<MultiCodeBlock>

```typescript
const token: SecurityToken = await apiCeo.getSecurityToken({ "ticker": "ACME" });
const issuance: Issuance = token.issuance;
```

```javascript
const token = await apiCeo.getSecurityToken({ "ticker": "ACME" });
const issuance = token.issuance;
```

</MultiCodeBlock>

Here too, in `issuance`, the context is still `apiCeo`. In fact, its [`parent`](https://developers.polymath.network/polymesh-sdk-api-reference/classes/issuance#properties-1) is the `token` itself.

<MultiCodeBlock>

```typescript
const issueQueue: TransactionQueue<SecurityToken> = await issuance.issue({
    "amount": new BigNumber("20000")
});
await issueQueue.run();
```

```javascript
const issueQueue = await issuance.issue({
    "amount": new BigNumber("20000")
});
await issueQueue.run();
```

</MultiCodeBlock>

<HighlightBox type="tip">

There is no beneficiary to mention because an `issue` command sends the shares to the issuance agent, which, at this point is the CEO. Additionally, it sends the shares to the default portfolio.

</HighlightBox>

At this point, Alice the CEO, has received shares. Not _her_ shares, though. We still need to send them over to Alice the individual.

## In which portfolio?

Now, Alice does not want to receive her ACME shares into her default portfolio. Instead, she wants to have them sent to a new "cold store" portfolio, she first needs to [create](https://developers.polymath.network/polymesh-sdk-api-reference/classes/portfolios#create) the portfolio.

Here we are talking about Alice, the eventual owner, not the CEO, so we are going to use _her_ Polymesh client instance:

<MultiCodeBlock>

```typescript
const alice: CurrentIdentity = await apiAlice.getCurrentIdentity();
const portfolios: Portfolios = alice.portfolios;
const portfolioQueue: TransactionQueue<NumberedPortfolio> = await portfolios.create({
    "name": "Cold store"
});
const coldStore: NumberedPortfolio = await portfolioQueue.run();
```

```javascript
const alice = await apiAlice.getCurrentIdentity();
const portfolios = alice.portfolios;
const portfolioQueue = await portfolios.create({
    "name": "Cold store"
});
const coldStore = await portfolioQueue.run();
```

</MultiCodeBlock>

To [retrieve](https://developers.polymath.network/polymesh-sdk-api-reference/classes/portfolios#getportfolio) the portfolio at a later date, anyone can use the string `coldStore.id`, or find the portfolio by name. Time to [move](https://developers.polymath.network/polymesh-sdk-api-reference/classes/portfolio#movefunds) the shares. Now that Alice has created the portfolio in which she wishes to receive her shares, she needs to prepare some information for her alter ego, the CEO:

<MultiCodeBlock>

```typescript
const aliceId: string = alice.did;
const coldStoreId: string = coldStore.id.toString(10);
```

```javascript
const aliceId = alice.did;
const coldStoreId = coldStore.id;
```

</MultiCodeBlock>

## Moving the shares, finally

Who creates the settlement instruction to move the shares? Alice, the CEO, so let's flip back to her. From her end, she needs to re-inflate some instances given the previous information:

<MultiCodeBlock>

```typescript
const ceo: CurrentIdentity = await apiCeo.getCurrentIdentity();
const ceoDefaultPortfolio: DefaultPortfolio = await ceo.portfolios.getPortfolio();
const ceoId: string = ceo.did;

const alice: Identity = await apiCeo.getIdentity({
    "did": aliceId
});
const aliceColdStore: Portfolio = await alice.portfolios.getPortfolio({
    "portfolioId": new BigNumber(coldStoreId)
});
```

```javascript
const ceo = await apiCeo.getCurrentIdentity();
const ceoDefaultPortfolio = await ceo.portfolios.getPortfolio();
const ceoId = ceo.did;

const alice = await apiCeo.getIdentity({
    "did": aliceId
});
const aliceColdStore = await alice.portfolios.getPortfolio({
    "portfolioId": new BigNumber(coldStoreId)
});
```

</MultiCodeBlock>

Now to the settlement instruction:

<MultiCodeBlock>

```typescript
const distributionInstructionQueue: TransactionQueue<Instruction> = await distributionVenue.addInstruction({
    "legs": [{
        "amount": new BigNumber(20000),
        "from": ceoDefaultPortfolio,
        "to": aliceColdStore,
        "token": token
    }]
});
const distributionInstruction: Instruction = await distributionInstructionQueue.run();
const distributionInstructionId: string = distributionInstruction.id.toString(10);
```

```javascript
const distributionInstructionQueue = await distributionVenue.addInstruction({
    "legs": [{
        "amount": new BigNumber(20000),
        "from": ceoDefaultPortfolio,
        "to": aliceColdStore,
        "token": token
    }]
});
const distributionInstruction = await distributionInstructionQueue.run();
const distributionInstructionId = distributionInstruction.id.toString(10);
```

</MultiCodeBlock>

This instruction is now recorded in the blockchain as pending. Alice the CEO is satisfied with it, so she goes ahead and affirms it. Remember that all the above actions where done in the context of `ceo`, so now it as simple as:

<MultiCodeBlock>

```typescript
await distributionInstruction.affirm();
```

```javascript
await distributionInstruction.affirm();
```

</MultiCodeBlock>

## Does Alice agree?

Now it is time to turn to Alice, the future share owner, and seek her affirmation. Since she is most likely on another computer or system, we need once more to reinflate the instruction from Alice's point of view. For that to happen, Alice the CEO needs to send `aliceAsCeoId`, `distributionVenueId` and `distributionInstructionId` to Alice's system:

<MultiCodeBlock>

```typescript
const ceo: Identity = await apiAlice.getIdentity({
    "did": ceoId
});
const venue: Venue = (await ceoId.getVenues()).find((venue: Venue) => {
    return venue.id.isEqualTo(new BigNumber(distributionVenueId));
});
const aliceInstruction: Instruction = (await venue.getPendingInstructions()).find((instruction: Instruction) => {
    return instruction.id.isEqualTo(distributionInstructionId);
});
```

```javascript
const ceo = await apiAlice.getIdentity({
    "did": ceoId
});
const venue = (await ceoId.getVenues()).find((venue) => {
    return venue.id.isEqualTo(new BigNumber(distributionVenueId));
});
const aliceInstruction = (await venue.getPendingInstructions()).find((instruction) => {
    return instruction.id.isEqualTo(distributionInstructionId);
});
```

</MultiCodeBlock>

Now, it is just a matter of affirming the instruction:

<MultiCodeBlock>

```typescript
const updatedInstruction: Instruction = await aliceInstruction.affirm();
```

```javascript
const updatedInstruction = await aliceInstruction.affirm();
```

</MultiCodeBlock>

And with this, Alice got her 20,000 shares.

## Can she confirm she received the shares?

Well, she can check what's inside her portfolio:

<MultiCodeBlock>

```typescript
const coldStore: NumberedPortfolio = await alice.portfolios.getPortfolio({
    "portfolioId": new BigNumber(coldStoreId)
});
const acmeBalances: PortfolioBalance[] = await coldStore.getTokenBalances({
    "tokens": [ "ACME" ]
});
const acmeBalance: PortfolioBalance = acmeBalances[0];
assert(acmeBalance.total.isEqualTo(new BigNumber("20000")));
```

```javascript
const coldStore = await alice.portfolios.getPortfolio({
    "portfolioId": new BigNumber(coldStoreId)
});
const acmeBalances = await coldStore.getTokenBalances({
    "tokens": [ "ACME" ]
});
const acmeBalance = acmeBalances[0];
assert(acmeBalance.total.isEqualTo(new BigNumber("20000")));
```

</MultiCodeBlock>


## How can Alice issue the shares of other founders?

As the primary issuance agent, she can repeat the steps to create one instruction per founder. On the other hand, if the founders have decided that they should all receive their shares in a single atomic instruction, then, Alice would have to create a single instruction with all the legs:

<MultiCodeBlock>

```typescript
const issueQueue: TransactionQueue<SecurityToken> = await issuance.issue({
    "amount": new BigNumber("100000")
});
await issueQueue.run();
const distributionInstructionQueue: TransactionQueue<Instruction> = await distributionVenue.addInstruction({
    "legs": [
        {
            "amount": new BigNumber(20000),
            "from": ceoDefaultPortfolio,
            "to": aliceColdStore,
            "token": token
        },
        {
            "amount": new BigNumber(30000),
            "from": ceoDefaultPortfolio,
            "to": bobTargetPortfolio,
            "token": token
        },
        {
            "amount": new BigNumber(50000),
            "from": ceoDefaultPortfolio,
            "to": carolTargetPortfolio,
            "token": token
        }
    ]
});
const distributionInstruction: Instruction = await distributionInstructionQueue.run();
const distributionInstructionId: string = distributionInstruction.id.toString(10);
```

```javascript
const issueQueue = await issuance.issue({
    "amount": new BigNumber("100000")
});
await issueQueue.run();
const distributionInstructionQueue = await distributionVenue.addInstruction({
    "legs": [
        {
            "amount": new BigNumber(20000),
            "from": ceoDefaultPortfolio,
            "to": aliceColdStore,
            "token": token
        },
        {
            "amount": new BigNumber(30000),
            "from": ceoDefaultPortfolio,
            "to": bobTargetPortfolio,
            "token": token
        },
        {
            "amount": new BigNumber(50000),
            "from": ceoDefaultPortfolio,
            "to": carolTargetPortfolio,
            "token": token
        }
    ]
});
const distributionInstruction = await distributionInstructionQueue.run();
const distributionInstructionId = distributionInstruction.id.toString(10);
```

</MultiCodeBlock>

Or whichever distribution was agreed between the parties. The advantage of this single operation is that all parties can see in one go whether the eventual outcome is as per previously agreed.

## When all is done

Assuming all parties have received their shares, it could be advantageous for the company to create a checkpoint. This post-issuance checkpoint would provide visibility about what was achieved during the issuance.

<!-- TODO when SDK exposes that -->

## Links

- SDK: https://developers.polymath.network/classic-sdk/globals
