---
title: Originate with the SDK
description: Originating Assets with the Polymesh SDK
slug: /originate/sdk
---

import {MultiCodeBlock} from 'gatsby-theme-apollo-docs';
import HighlightBox from "../../src/components/HighlightBox"

In the previous exercise, we originated a simple asset, ACME equity. As we did so, we discovered that there are many more configurable properties available to address common business requirements. Everything that can be done with the Polymesh Dashboard, and more, can be done with integrations using the SDK. Indeed, the dashboard itself is constructed using the SDK.

In our simple example, ACME will be unlikely to originate new securities very frequently. Provided that the parameters exposed through the Polymesh Dashboard are appropriate for each case, AMCE will probably never need to use the SDK. However, if ACME uses a service to perform the actual origination then that business may face considerable repetition. The SDK can help with that.

The Polymesh Dashboard is constructed with the SDK. Therefore, every process you see there has corresponding SDK methods you can use in integrations with internal systems. For example, checkpoints and the two methods of creating them were briefly describe in the introduction. The SDK methods, these are:

* dispatchable: ```create_checkpoint(ticker)```, or
* dispatchable: ```create_checkpoint_schedule(ticker, schedule)```.

You can find complete documentation in the SDK documentation.

## Familiar

Internal systems can integrate with Polymesh using the SDK. The SDK presents a comprehensive set of business-level methods for inspecting and interacting with the Polymesh network using familiar Javascript or Typescript at the developer's discretion.

## Preconditions

We assume that:

* Alice, ACME's acting agent, already has a Polymesh identity.
* A Polymesh client has been [instantiated](https://developers.polymath.network/polymesh-sdk-api-reference/classes/polymesh#static-connect) by Alice so she can do the next actions:
    <MultiCodeBlock>

    ```typescript
    const apiAlice: Polymesh = await Polymesh.connect({
        "nodeUrl": "wss://pme.polymath.network", // For instance, or the proper network
        "accountMnemonic": "word1 word2 ..."
    });
    ```

    ```javascript
    const apiAlice = await Polymesh.connect({
        "nodeUrl": "wss://pme.polymath.network", // For instance, or the proper network
        "accountMnemonic": "word1 word2 ..."
    });
    ```

    </MultiCodeBlock>

## Ticker reservation

Alice needs to [reserve](https://developers.polymath.network/polymesh-sdk-api-reference/classes/polymesh#reserveticker) the ACME ticker:

<MultiCodeBlock>

```typescript
const reservationQueue: TransactionQueue‹TickerReservation› = await apiAlice.reserveTicker({
    "ticker": "ACME"
});
```

```javascript
const reservationQueue = await apiAlice.reserveTicker({
    "ticker": "ACME"
});
```

</MultiCodeBlock>

The queue is just that, a queue. Notice that it is a generic type specified with `TickerReservation`. This means that eventually, the object the queue returns is an instance of `TickerReservation`. Let's [run](https://developers.polymath.network/polymesh-sdk-api-reference/classes/transactionqueue#run) it.

<MultiCodeBlock>

```typescript
const reservation: TickerReservation = await reservationQueue.run();
```

```javascript
const reservation = await reservationQueue.run();
```

</MultiCodeBlock>

It is at this point that the necessary signatures are collected for the transactions. `apiAlice` was created straight with the mnemonic, so the signature will happen automatically. However, if this was taking place in the browser, for instance in the Token dashboard and the Polymesh Wallet extension, then there is a possibility that Alice will refuse to sign when prompted.

<HighlightBox type="tip">

You would need to `try .run() catch` it for errors. Here, we opted for clarity and omitted this _detail_.

</HighlightBox>

Also note that with `await reservationQueue.run()` we patiently wait for the queue to have finalised. However any `TransactionQueue` can provide intermediate information with regards to its changing status and that of its component transactions. If this is of interest to you, you can pass callbacks to [`onStatusChange`](https://developers.polymath.network/polymesh-sdk-api-reference/classes/transactionqueue#onstatuschange) and [`onTransactionStatusChange`](https://developers.polymath.network/polymesh-sdk-api-reference/classes/transactionqueue#ontransactionstatuschange).

At this stage, Alice owns the reservation. You can confirm it with the following:

<MultiCodeBlock>

```typescript
const alice: CurrentIdentity = await apiAlice.getCurrentIdentity();
const details: TickerReservationDetails = await reservation.details();
const owner: Identity = details.owner;
assert(owner.did == alice.did);
```

```javascript
const alice = await apiAlice.getCurrentIdentity();
const { owner } = await reservation.details();
assert(owner.did == alice.did);
```

</MultiCodeBlock>

Something is not immediately apparent from the few lines of code above. It is nonetheless important to point it out. When we created `apiAlice` with `await Polymesh.connect()`, we passed an identifier `accountMnemonic` that allowed the SDK to recreate the private key. As a repeat of what was covered in the introduction module, this private key is not the Polymesh identity proper. The private key is associated to an identity, whether as a primary key or a secondary one. And when it is used to sign a transaction, it is the associated identity that will be considered to be the one doing the action.

<HighlightBox type="info">

So when we wrote `await` in `await apiAlice.getCurrentIdentity()`, this is no accident. We indeed need to do a round trip to the blockchain to know what identity our private key is associated with.

</HighlightBox>

## Ticker creation

With the reservation done, it is time to issue the ticker proper. Oh wait! The reservation may have happened some time ago and your `const reservation: TickerReservation` instance is no longer in memory. How do you get it back? With [getTickerReservation](https://developers.polymath.network/polymesh-sdk-api-reference/classes/polymesh#gettickerreservation):

<MultiCodeBlock>

```typescript
const reservation: TickerReservation = await apiAlice.getTickerReservation({
    "ticker": "ACME"
});
```

```javascript
const reservation = await apiAlice.getTickerReservation({
    "ticker": "ACME"
});
```

</MultiCodeBlock>

You will note that the class `TickerReservation` keeps a [`protected context: Context`](https://developers.polymath.network/polymesh-sdk-api-reference/classes/tickerreservation#properties-1). This `context` in turn keeps a [`polymeshApi`](https://developers.polymath.network/polymesh-sdk-api-reference/classes/context#properties-1). It is in there that we find the implicit knowledge that it is Alice that is asking for the next actions. If it were any other identity that had asked for the reservation, this other identity would not be able to `.createToken` because they do not own the reservation.

With our `reservation` in memory, we now can:

<MultiCodeBlock>

```typescript
const tokenQueue: TransactionQueue<SecurityToken> = await reservation.createToken({
    "name": "ACME Co",
    "tokenType": KnownTokenType.EquityPreferred,
    "isDivisible": false,
    "totalSupply": new BigNumber("100000")
});
```

```javascript
const tokenQueue = await reservation.createToken({
    "name": "ACME Co",
    "tokenType": "EquityPreferred",
    "isDivisible": false,
    "totalSupply": new BigNumber("100000")
});
```

</MultiCodeBlock>

We have another queue, so as we did before:

<MultiCodeBlock>

```typescript
const token: SecurityToken = await tokenQueue.run();
```

```javascript
const token = await tokenQueue.run();
```

</MultiCodeBlock>

Implicit in the creation of this token is that Alice is both the token's owner and its primary issuance agent (PIA). We are satisfied with this situation. Alice is not yet a holder of any amount of the security token, though, we remedy that in the next chapter "Distribution".

## Methods Reference

## Exercise

## Links

- SDK, create_checkpoint
- SDK, create_checkpoint_schedule
