---
title: With the SDK
description: Originating Assets with the Polymesh SDK
slug: /originate/sdk
---

import {MultiCodeBlock} from 'gatsby-theme-apollo-docs';
import HighlightBox from "../../src/components/HighlightBox"

In the previous exercise, we originated a simple asset, ACME Co equity. As we did so, we discovered that there are many more configurable properties available to address common business requirements. Everything that can be done with the Polymesh Dashboard, and more, can be done with integrations using the SDK. Indeed, the dashboard itself is constructed using the SDK.

In our simple example, ACME Co will be unlikely to originate new securities very frequently. Provided that the parameters exposed through the Polymesh Dashboard are appropriate for each case, AMCE Co will probably never need to use the SDK. However, if ACME Co uses a service to perform the actual origination then that business may face considerable repetition. The SDK can help with that.

The Polymesh Dashboard is constructed with the SDK. Therefore, every process you see there has its corresponding SDK methods you can use in integrations with internal systems. Fortunately, the SDK's methods are intelligible when you know what it is you intend to do.

You can find complete documentation in the [SDK documentation](https://developers.polymath.network/classic-sdk/globals).

## Familiar

Internal systems can integrate with Polymesh using the SDK. The SDK presents a comprehensive set of business-level methods for inspecting and interacting with the Polymesh network using familiar Javascript or Typescript at the developer's discretion.

## Preconditions

If you went through the quick start, we can assume that you have created an account on the Polymesh testnet and that you have credited it with POLY. We shall call this account `alice`, and it represents a personal account. To go through the previous Token Studio exercise, you had to create another identity, that of Alice acting as the CEO of ACME Co. We shall call this account `aliceAsCeo`:

* Alice, ACME's acting agent, already has a Polymesh identity, tied to a primary private key named `aliceAsCeo`.
* `aliceAsCeo`'s private key is based on the `"word1 word2 ..."` mnemonic.
* A Polymesh client has been [instantiated](https://developers.polymath.network/polymesh-sdk-api-reference/classes/polymesh#static-connect) by Alice so she can do the next actions:
    <MultiCodeBlock>

    ```typescript
    const apiAliceAsCeo: Polymesh = await Polymesh.connect({
        "nodeUrl": "wss://alcyone-rpc.polymesh.live", // For instance, or the proper network
        "accountMnemonic": "word1 word2 ..."
    });
    ```

    ```javascript
    const apiAliceAsCeo = await Polymesh.connect({
        "nodeUrl": "wss://alcyone-rpc.polymesh.live", // For instance, or the proper network
        "accountMnemonic": "word1 word2 ..."
    });
    ```

    </MultiCodeBlock>

## Ticker reservation

Before creating the token proper, Alice needs to [reserve](https://developers.polymath.network/polymesh-sdk-api-reference/classes/polymesh#reserveticker) the ACME ticker so that it is not squatted while the founders incorporate the company. Think of it on same level as grabbing the `.com` domain as early as possible:

<MultiCodeBlock>

```typescript
const reservationQueue: TransactionQueue<TickerReservation> = await apiAliceAsCeo.reserveTicker({
    "ticker": "ACME"
});
```

```javascript
const reservationQueue = await apiAliceAsCeo.reserveTicker({
    "ticker": "ACME"
});
```

</MultiCodeBlock>

The `TransactionQueue` type is just that, a queue. The transactions in it have not been launched. Notice that:

* It is a generic type specified with `TickerReservation`. This means that eventually, the object the queue returns is an instance of `TickerReservation`.
* The constructor of `TransactionQueue` expects a [`context`](https://developers.polymath.network/polymesh-sdk-api-reference/classes/transactionqueue#constructor); it is in this `context` object that `apicAliceAsCeo` is referenced so it is understood that this is the private key to use.
* Each transaction in the queue has its own status.
* The queue itself has its own [status](https://developers.polymath.network/polymesh-sdk-api-reference/classes/transactionqueue#status).

Of note, the reservation cost, at the time of writing, is of **2,500 POLY**, before network fees. Let's [run](https://developers.polymath.network/polymesh-sdk-api-reference/classes/transactionqueue#run) it.

<MultiCodeBlock>

```typescript
const reservation: TickerReservation = await reservationQueue.run();
```

```javascript
const reservation = await reservationQueue.run();
```

</MultiCodeBlock>

It is at this point that the necessary signatures are collected for the transactions. `apiAliceasCeo` was created straight with the mnemonic, so the signature will be affixed automatically. However, if this was taking place in the browser, for instance in the Token Studio dashboard and with the Polymesh Wallet extension, then there is a possibility that Alice will refuse to sign when prompted.

<HighlightBox type="tip">

You would need to `try .run() catch` it for errors. Here, we opted for clarity and omitted this _detail_.

</HighlightBox>

Also note that with `await reservationQueue.run()` we patiently wait for the queue to have finalised. However any `TransactionQueue` can provide intermediate information with regards to its changing status and that of its component transactions. If this is of interest to you, you can pass callbacks to [`onStatusChange`](https://developers.polymath.network/polymesh-sdk-api-reference/classes/transactionqueue#onstatuschange) and [`onTransactionStatusChange`](https://developers.polymath.network/polymesh-sdk-api-reference/classes/transactionqueue#ontransactionstatuschange).

At this stage, Alice owns the reservation. You can confirm it with the following:

<MultiCodeBlock>

```typescript
const aliceAsCeo: CurrentIdentity = await apiAliceAsCeo.getCurrentIdentity();
const details: TickerReservationDetails = await reservation.details();
const owner: Identity = details.owner;
assert(owner.did == aliceAsCeo.did);
```

```javascript
const aliceAsCeo = await apiAliceAsCeo.getCurrentIdentity();
const { owner } = await reservation.details();
assert(owner.did == aliceAsCeo.did);
```

</MultiCodeBlock>

Something is not immediately apparent from the few lines of code above. It is nonetheless important to point it out. When we created `apiAliceAsCeo` with `await Polymesh.connect()`, we passed an identifier `accountMnemonic` that allowed the SDK to recreate the private key. At the risk of repeating what was covered in the introduction module, this private key is not the Polymesh identity proper, nor is the public key. The public key is associated with an identity, whether as a primary key or a secondary one. And when the private key is used to sign a transaction, it is the **associated identity** that will be considered to be the one doing the action. This associated identity information is not embedded in the private key. It is an association that is stored on the blockchain, and as such, it needs to be retrieved to be known.

<HighlightBox type="info">

So when we wrote `await` in `await apiAlice.getCurrentIdentity()`, this is no accident. We indeed need to do a round trip to the blockchain to know what identity our public key is associated with.

</HighlightBox>

## Ticker creation

With the reservation done, it is time to issue the ticker proper. Oh wait! The reservation may have happened some time ago. After all a reservation remains valid for 60 days, for instance. And your `const reservation: TickerReservation` instance is unlikely to be any longer in memory. How do you get it back? With [`getTickerReservation`](https://developers.polymath.network/polymesh-sdk-api-reference/classes/polymesh#gettickerreservation):

<MultiCodeBlock>

```typescript
const apiAliceAsCeo: Polymesh = await Polymesh.connect({...});
const reservation: TickerReservation = await apiAliceAsCeo.getTickerReservation({
    "ticker": "ACME"
});
```

```javascript
const apiAliceAsCeo = await Polymesh.connect({...});
const reservation = await apiAliceAsCeo.getTickerReservation({
    "ticker": "ACME"
});
```

</MultiCodeBlock>

You will note that the class `TickerReservation`, just like the transaction queue, keeps a [`protected context: Context`](https://developers.polymath.network/polymesh-sdk-api-reference/classes/tickerreservation#properties-1). This `context` in turn keeps a [`polymeshApi`](https://developers.polymath.network/polymesh-sdk-api-reference/classes/context#properties-1). It is in there that we find the implicit knowledge that it is `aliceAsCeo`'s identity that is asking for the next actions. If it were any other **identity** that had called `getTickerReservation`, this other identity would not be able to follow up with a `.createToken` command because they do not own the reservation.

With our `reservation` in memory, and 10,000 POLY in `aliceAsCeo` wallet, which is the cost of creation of 1 security token, we now can create it:

<MultiCodeBlock>

```typescript
const tokenQueue: TransactionQueue<SecurityToken> = await reservation.createToken({
    "name": "ACME Co",
    "tokenType": KnownTokenType.EquityPreferred,
    "isDivisible": false
});
```

```javascript
const tokenQueue = await reservation.createToken({
    "name": "ACME Co",
    "tokenType": "EquityPreferred",
    "isDivisible": false
});
```

</MultiCodeBlock>

We have another queue, so as we did before:

<MultiCodeBlock>

```typescript
const token: SecurityToken = await tokenQueue.run();
```

```javascript
const token = await tokenQueue.run();
```

</MultiCodeBlock>

Implicit in the creation of this token is that Alice, as the CEO, is both the token's owner and its primary issuance agent (PIA). We are satisfied with this situation. Alice, under her personal account, is not yet a holder of any amount of the security token, though, we remedy that in the next chapter "Distribution".

## Compliance

However, as the CEO, Alice still needs to do one more step, define the conditions of ownership. Namely, require anyone who acquires the token to not be a resident of Liechtenstein. An exception will be made of the primary issuance agent who is simply used as a conduit, and can send to anyone.

<MultiCodeBlock>

```typescript
const acmeCompliance: Compliance = token.compliance;
const acmeRequirements: Requirements = acmeCompliance.requirements;
const aliceAsCeo = await apiAliceAsCeo.getCurrentIdentity();
const setRequirementsQueue: TransactionQueue<SecurityToken> = await acmeRequirements.set({
    "requirements": [
        [
            {
                "target": ConditionTarget.Sender,
                "type": ConditionType.IsPrimaryIssuanceAgent
            }
        ],
        [
            {
                "target": ConditionTarget.Receiver,
                "type": ConditionType.IsPresent,
                "claim": {
                    "type": ClaimType.KnowYourCustomer,
                    "scope": {
                        "type": ScopeType.Ticker,
                        "value": token.ticker
                    }
                },
                "trustedClaimIssuers": [{
                    "identity": aliceAsCeo.did,
                    "trustedFor": [ClaimType.KnowYourCustomer]
                }]
            },
            {
                "target": ConditionTarget.Receiver,
                "type": ConditionType.IsAbsent,
                "claim": {
                    "type": ClaimType.Jurisdiction,
                    "code": CountryCode.Li,
                    "scope": {
                        "type": ScopeType.Ticker,
                        "value": token.ticker
                    }
                },
                "trustedClaimIssuers": [{
                    "identity": aliceAsCeo.did,
                    "trustedFor": [ClaimType.Jurisdiction]
                }]
            }
        ]
    ]
});
const updatedToken: SecurityToken = await setRequirementsQueue.run();
```

```javascript
const acmeCompliance = token.compliance;
const acmeRequirements = acmeCompliance.requirements;
const setRequirementsQueue = await acmeRequirements.set({
    "requirements": [
        [
            {
                "target": "Sender",
                "type": "IsPrimaryIssuanceAgent"
            }
        ],
        [
            {
                "target": "Receiver",
                "type": "IsPresent",
                "claim": {
                    "type": "KnowYourCustomer",
                    "scope": {
                        "type": "Ticker",
                        "value": token.ticker
                    }
                },
                "trustedClaimIssuers": [{
                    "identity": aliceAsCeo.did,
                    "trustedFor": ["KnowYourCustomer"]
                }]
            },
            {
                "target": "Receiver",
                "type": "IsAbsent",
                "claim": {
                    "type": "Jurisdiction",
                    "code": "Li",
                    "scope": {
                        "type": "Ticker",
                        "value": token.ticker
                    }
                },
                "trustedClaimIssuers": [{
                    "identity": aliceAsCeo.did,
                    "trustedFor": ["Jurisdiction"]
                }]
            }
        ]
    ]
});
const updatedToken: SecurityToken = await setRequirementsQueue.run();
```

</MultiCodeBlock>


## Methods Reference

## Exercise

## Links

- SDK: https://developers.polymath.network/classic-sdk/globals
