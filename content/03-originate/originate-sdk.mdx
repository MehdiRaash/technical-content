---
title: With the SDK
description: Originating Assets with the Polymesh SDK
slug: /originate/sdk
---

import {MultiCodeBlock} from 'gatsby-theme-apollo-docs';
import HighlightBox from "../../src/components/HighlightBox"

In the previous exercise, we originated a simple asset, ACME Co equity. As we did so, we discovered that there are many more configurable properties available to address common business requirements. Everything that can be done with the Polymesh Dashboard, and more, can be done with integrations using the SDK. Indeed, the dashboard itself is constructed using the SDK.

In our simple example, ACME Co will be unlikely to originate new securities very frequently. Provided that the parameters exposed through the Polymesh Dashboard are appropriate for each case, AMCE Co will probably never need to use the SDK. However, if ACME Co uses a service to perform the actual origination then that business may face considerable repetition. The SDK can help with that.

The Polymesh Dashboard is constructed with the SDK. Therefore, every process you see there has its corresponding SDK methods you can use in integrations with internal systems. Fortunately, the SDK's methods are intelligible when you know what it is you intend to do.

You can find complete documentation in the [SDK documentation](https://developers.polymath.network/classic-sdk/globals).

## Familiar

Internal systems can integrate with Polymesh using the SDK. The SDK presents a comprehensive set of business-level methods for inspecting and interacting with the Polymesh network using familiar Javascript or Typescript at the developer's discretion.

## Preconditions

If you went through the quick start, we can assume that you have created an account (a public / private key pair) on the Polymesh testnet, that you associated it with an identity, and that you credited it with POLYX. We shall call this personal account `aliceKey`, and the personal identity it represents `alice`. Here, we are going to follow along the Token Studio Dashboard exercise, and do the same _mistake_, whereby she creates the token with her personal account, and which we will eventually fix. The credible simple reason why Alice created the token with her personal account is that her and her co-founders wanted to act fast so as to have the ticker available before getting the company through CDD.

To recap:

* Alice, ACME's CEO and acting agent, already has an **individual** Polymesh identity, tied to a primary private key named `alice`.
* `aliceKey`'s private key is based on the `"word1 word2 ..."` mnemonic.
* A Polymesh client has been [instantiated](https://developers.polymath.network/polymesh-sdk-api-reference/classes/polymesh#static-connect) by Alice so she can do the next actions:
    <MultiCodeBlock>

    ```typescript
    const apiAlice: Polymesh = await Polymesh.connect({
        "nodeUrl": "wss://alcyone-rpc.polymesh.live", // For instance, or the proper network
        "accountMnemonic": "word1 word2 ..."
    });
    ```

    ```javascript
    const apiAlice = await Polymesh.connect({
        "nodeUrl": "wss://alcyone-rpc.polymesh.live", // For instance, or the proper network
        "accountMnemonic": "word1 word2 ..."
    });
    ```

    </MultiCodeBlock>

## Ticker reservation

Before creating the token proper, Alice needs to [reserve](https://developers.polymath.network/polymesh-sdk-api-reference/classes/polymesh#reserveticker) the ACME ticker so that it is not squatted while the founders incorporate the company. Think of it on the same level as grabbing your `.com` domain as early as possible:

<MultiCodeBlock>

```typescript
const reservationQueue: TransactionQueue<TickerReservation> = await apiAlice.reserveTicker({
    "ticker": "ACME"
});
```

```javascript
const reservationQueue = await apiAlice.reserveTicker({
    "ticker": "ACME"
});
```

</MultiCodeBlock>

The `TransactionQueue` type is just that, a queue. The transaction(s) in it have not been launched. Notice that:

* It is a generic type parameterised with `TickerReservation`. This means that, eventually, the queue yields an instance of `TickerReservation`.
* The constructor of `TransactionQueue` expects a [`context`](https://developers.polymath.network/polymesh-sdk-api-reference/classes/transactionqueue#constructor); it is in this `context` object that `apiAlice` is referenced so it is understood that `aliceKey` is the private key to use.
* Each transaction in the queue has its own status.
* The queue itself has its own [status](https://developers.polymath.network/polymesh-sdk-api-reference/classes/transactionqueue#status).

Of note, the reservation cost, at the time of writing, is of **2,500 POLYX**, before network fees. Let's [run](https://developers.polymath.network/polymesh-sdk-api-reference/classes/transactionqueue#run) it.

<MultiCodeBlock>

```typescript
const reservation: TickerReservation = await reservationQueue.run();
```

```javascript
const reservation = await reservationQueue.run();
```

</MultiCodeBlock>

It is at this point that the necessary signatures are collected for the transactions. `apiAlice` was created straight with the mnemonic, so the signature will be affixed automatically. However, if this was taking place in the browser, for instance in the Token Studio dashboard and with the Polymesh Wallet extension, then there is a possibility that Alice will refuse to sign when prompted.

<HighlightBox type="tip">

You would need to `try .run() catch` it for errors. Here, we opted for clarity and omitted this _detail_.

</HighlightBox>

Also note that with `await reservationQueue.run()` we patiently wait for the queue to have finalised all its transactions. However, a `TransactionQueue` can provide intermediate information with regards to its changing status and that of its component transactions. If this is of interest to you, you can pass callbacks to [`onStatusChange`](https://developers.polymath.network/polymesh-sdk-api-reference/classes/transactionqueue#onstatuschange) and [`onTransactionStatusChange`](https://developers.polymath.network/polymesh-sdk-api-reference/classes/transactionqueue#ontransactionstatuschange).

At this stage, Alice owns the reservation. You can confirm it with the following:

<MultiCodeBlock>

```typescript
const alice: CurrentIdentity = await apiAlice.getCurrentIdentity();
const details: TickerReservationDetails = await reservation.details();
const owner: Identity = details.owner;
assert(owner.did == alice.did);
```

```javascript
const alice = await apiAlice.getCurrentIdentity();
const { owner } = await reservation.details();
assert(owner.did == alice.did);
```

</MultiCodeBlock>

Something is not immediately apparent from the few lines of code above. It is nonetheless important to point it out. When we created `apiAlice` with `await Polymesh.connect()`, we passed an identifier `accountMnemonic` that allowed the SDK to recreate the `aliceKey` private key. At the risk of repeating what was covered in the introduction module, this private key is not the Polymesh identity proper, nor is it the public key. The public key is associated with an identity, whether as a primary key, like here, or a secondary one. And when the private key is used to sign a transaction, it is the **associated identity** that will be considered to be the one doing the action. This associated identity information is not embedded in the private key. It is an association that is stored on the blockchain, may change in the future, and as such, it needs to be retrieved to be known.

<HighlightBox type="info">

So when we wrote `await` in `await apiAlice.getCurrentIdentity()`, this is no accident. We indeed need to do a round trip to the blockchain to know what identity our public key is associated with.

</HighlightBox>

## Ticker creation

With the reservation done, it is time to issue the ticker proper. Oh wait! The reservation may have happened some time ago. After all a reservation remains valid for 60 days, for instance. And your `const reservation: TickerReservation` instance is unlikely to be any longer in memory. How do you get it back? With [`getTickerReservation`](https://developers.polymath.network/polymesh-sdk-api-reference/classes/polymesh#gettickerreservation):

<MultiCodeBlock>

```typescript
const apiAlice: Polymesh = await Polymesh.connect({...});
const reservation: TickerReservation = await apiCeo.getTickerReservation({
    "ticker": "ACME"
});
```

```javascript
const apiAlice = await Polymesh.connect({...});
const reservation = await apiCeo.getTickerReservation({
    "ticker": "ACME"
});
```

</MultiCodeBlock>

You will note that the class `TickerReservation`, just like the transaction queue, keeps a [`protected context: Context`](https://developers.polymath.network/polymesh-sdk-api-reference/classes/tickerreservation#properties-1). This `context` in turn keeps a [`polymeshApi`](https://developers.polymath.network/polymesh-sdk-api-reference/classes/context#properties-1). It is in there that we find the implicit knowledge that it is `alice`'s identity that is asking for the next actions. If it were any other **identity** that had called `getTickerReservation`, this other identity would not be able to follow up with a `.createToken` command because it does not own the reservation.

With our `reservation` in memory, and 10,000 POLYX in `alice`'s wallet, which is the cost of creation of 1 security token, we now can create it:

<MultiCodeBlock>

```typescript
const tokenQueue: TransactionQueue<SecurityToken> = await reservation.createToken({
    "name": "ACME Co",
    "tokenType": KnownTokenType.EquityPreferred,
    "isDivisible": false
});
```

```javascript
const tokenQueue = await reservation.createToken({
    "name": "ACME Co",
    "tokenType": "EquityPreferred",
    "isDivisible": false
});
```

</MultiCodeBlock>

We have another queue, so as we did before:

<MultiCodeBlock>

```typescript
const token: SecurityToken = await tokenQueue.run();
```

```javascript
const token = await tokenQueue.run();
```

</MultiCodeBlock>

Implicit in the creation of this token is that Alice, as a private individual, is both the token's owner and its primary issuance agent (PIA). We were satisfied with this situation only up to this point. Now this needs to change. Alice, under her personal account, is not yet a holder of any amount of the security token, though, we remedy that in the next chapter "Distribution".

This `token` instance will not always be in memory, so if we wanted to fetch it at a later date, we would do:

<MultiCodeBlock>

```typescript
const token: SecurityToken = await apiCeo.getSecurityToken({ "ticker": "ACME" });
```

```javascript
const token = await apiCeo.getSecurityToken({ "ticker": "ACME" });
```

</MultiCodeBlock>

## Secondary Keys

Now we assume that ACME has gone through CDD and has an account, complete with a mnemonic and an identity, which, in a mirror fashion of that of Alice gives us:

<MultiCodeBlock>

```typescript
const apiAcme: Polymesh = await Polymesh.connect({
    "nodeUrl": "wss://alcyone-rpc.polymesh.live", // For instance, or the proper network
    "accountMnemonic": "word21 word22 ..."
});
const acme: CurrentIdentity = await apiAcme.getCurrentIdentity();
const acmeDid: string = acme.did;
```

```javascript
const apiAcme = await Polymesh.connect({
    "nodeUrl": "wss://alcyone-rpc.polymesh.live", // For instance, or the proper network
    "accountMnemonic": "word21 word22 ..."
});
const acme = await apiAcme.getCurrentIdentity();
const acmeDid = acme.did;
```

</MultiCodeBlock>

On her end, Alice, has created another mnemonic for a private key she intends to use when she acts as the CEO of ACME. Again:

<MultiCodeBlock>

```typescript
const apiCeo: Polymesh = await Polymesh.connect({
    "nodeUrl": "wss://alcyone-rpc.polymesh.live", // For instance, or the proper network
    "accountMnemonic": "word31 word32 ..."
});
```

```javascript
const apiCeo = await Polymesh.connect({
    "nodeUrl": "wss://alcyone-rpc.polymesh.live", // For instance, or the proper network
    "accountMnemonic": "word31 word32 ..."
});
```

</MultiCodeBlock>

At this point, `apiCeo` has no associated identity. It is an account in search of an identity. Alice first needs to get her public key:

<MultiCodeBlock>

```typescript
const pubCeo: string = apiCeo.key;
```

```javascript
const pubCeo = apiCeo.key;
```

</MultiCodeBlock>

Then she needs to send this `pubCeo` information to the computer that holds `apiAcme`. When this is done, the company can invite her to be a secondary key:

<MultiCodeBlock>

```typescript
const acme: CurrentIdentity = await apiAcme.getCurrentIdentity();
await acme.inviteAccount({
    "targetAccount": pubCeo
});
```

```javascript
const acme = await apiAcme.getCurrentIdentity();
await acme.inviteAccount({
    "targetAccount": pubCeo
});
```

</MultiCodeBlock>

With the invitation sent out, back at her computer, Alice, with knowledge of ACME identity's `acmeDid` can do:

<MultiCodeBlock>

```typescript
const ceoAccount: CurrentAccount = apiCeo.getAccount();
const pendingAuthorizations: AuthorizationRequest[] = await ceoAccount.authorizations.getReceived();
const acmeAuthorization: AuthorizationRequest = pendingAuthorizations
    .find((pendingAuthorization: AuthorizationRequest) => {
        return pendingAuthorization.issuer.did == acmeDid;
    });
await acmeAuthorization.accept();
```

```javascript
const ceoAccount = apiCeo.getAccount();
const pendingAuthorizations = await ceoAccount.authorizations.getReceived();
const acmeAuthorization = pendingAuthorizations
    .find((pendingAuthorization) => {
        pendingAuthorization.issuer.did == acmeDid;
    });
await acmeAuthorization.accept();
```

</MultiCodeBlock>

With this done, `apiCeo` now allows Alice to properly act as the CEO, on behalf of ACME.

## Token Ownership Transfer

With the keys and identities finally set right, it is time for Alice to fix the token situation, and transfer its ownership to ACME. Since it is Alice the individual who owns the token, she has to go back to using her personal account.

<MultiCodeBlock>

```typescript
const token: SecurityToken = await apiAlice.getSecurityToken({
    "ticker": "ACME"
});
await token.transferOwnership({
    "target": acmeDid
});
```

```javascript
const token = await apiAlice.getSecurityToken({
    "ticker": "ACME"
});
await token.transferOwnership({
    "target": acmeDid
});
```

</MultiCodeBlock>

With the authorisation on the way, Alice can stay on the same computer and switch from her personal identity to her identity as the CEO of ACME to accept the authorisation. She first needs to recall her personal did.

<MultiCodeBlock>

```typescript
const alice: CurrentIdentity = await apiAlice.getCurrentIdentity();
const aliceDid: string = alice.did;
```

```javascript
const alice = await apiAlice.getCurrentIdentity();
const aliceDid string = alice.did;
```

</MultiCodeBlock>

So she can narrow down the authorisation.

<MultiCodeBlock>

```typescript
const pendingAuthorizations: AuthorizationRequest[] = await ceoAccount.authorizations.getReceived();
const transferAuthorization: AuthorizationRequest = pendingAuthorizations
    .find((pendingAuthorization: AuthorizationRequest) => {
        return pendingAuthorization.issuer.did == aliceDid;
    });
await transferAuthorization.accept();
```

```javascript
const pendingAuthorizations = await ceoAccount.authorizations.getReceived();
const transferAuthorization = pendingAuthorizations
    .find((pendingAuthorization) => {
        return pendingAuthorization.issuer.did == aliceDid;
    });
await transferAuthorization.accept();
```

</MultiCodeBlock>

With this, the token is rightfully owned by ACME the company.

## Compliance

We are not done yet with the token, though. As the CEO, Alice still needs to do one more step, that is, define the conditions of ownership. Namely, require anyone who acquires the token to not be a resident of Liechtenstein. An exception will be made of the primary issuance agent who is simply used as a conduit, and can send to anyone. We use the CEO's identity as the KYC service provider, but realistically, it should be another identity.

<MultiCodeBlock>

```typescript
const acmeCompliance: Compliance = token.compliance;
const acmeRequirements: Requirements = acmeCompliance.requirements;
const ceo: CurrentIdentity = await apiCeo.getCurrentIdentity();
const setRequirementsQueue: TransactionQueue<SecurityToken> = await acmeRequirements.set({
    "requirements": [
        [
            {
                "target": ConditionTarget.Sender,
                "type": ConditionType.IsPrimaryIssuanceAgent
            }
        ],
        [
            {
                "target": ConditionTarget.Receiver,
                "type": ConditionType.IsPresent,
                "claim": {
                    "type": ClaimType.KnowYourCustomer,
                    "scope": {
                        "type": ScopeType.Ticker,
                        "value": token.ticker
                    }
                },
                "trustedClaimIssuers": [{
                    "identity": ceo.did,
                    "trustedFor": [ClaimType.KnowYourCustomer]
                }]
            },
            {
                "target": ConditionTarget.Receiver,
                "type": ConditionType.IsAbsent,
                "claim": {
                    "type": ClaimType.Jurisdiction,
                    "code": CountryCode.Li,
                    "scope": {
                        "type": ScopeType.Ticker,
                        "value": token.ticker
                    }
                },
                "trustedClaimIssuers": [{
                    "identity": ceo.did,
                    "trustedFor": [ClaimType.Jurisdiction]
                }]
            }
        ]
    ]
});
const updatedToken: SecurityToken = await setRequirementsQueue.run();
```

```javascript
const acmeCompliance = token.compliance;
const acmeRequirements = acmeCompliance.requirements;
const ceo = await apiCeo.getCurrentIdentity();
const setRequirementsQueue = await acmeRequirements.set({
    "requirements": [
        [
            {
                "target": "Sender",
                "type": "IsPrimaryIssuanceAgent"
            }
        ],
        [
            {
                "target": "Receiver",
                "type": "IsPresent",
                "claim": {
                    "type": "KnowYourCustomer",
                    "scope": {
                        "type": "Ticker",
                        "value": token.ticker
                    }
                },
                "trustedClaimIssuers": [{
                    "identity": ceo.did,
                    "trustedFor": ["KnowYourCustomer"]
                }]
            },
            {
                "target": "Receiver",
                "type": "IsAbsent",
                "claim": {
                    "type": "Jurisdiction",
                    "code": "Li",
                    "scope": {
                        "type": "Ticker",
                        "value": token.ticker
                    }
                },
                "trustedClaimIssuers": [{
                    "identity": ceo.did,
                    "trustedFor": ["Jurisdiction"]
                }]
            }
        ]
    ]
});
const updatedToken: SecurityToken = await setRequirementsQueue.run();
```

</MultiCodeBlock>


## Methods Reference

## Exercise

## Links

- SDK: https://developers.polymath.network/classic-sdk/globals
